= directives =

directives are part of the assembler, and not the CPU. 
They're used to tell the assembler to do something or tell the assembler 
something and aren't translated into machine code. 

they're usually used for:
- defining constants
- define memory to store data into
- group memory into segments
- conditionally include source code
- include other files 

nasm passes through a preprocessor like c and has many same preprocessor commands 
as C. Nasm's ones start with % instead of # though.

== equ ==

equ can be used to define a symbol. Symbols are constants that are used in assembly; 
the format is:
                            symbol equ value
symbol values can't be redefined later

== %define directive == 

this directive is similar to C's define. Commonly used to define constant macros 
like in C. 

%define SIZE 100
mov     eax, SIZE ; moves 100 into eax

macros are more flexible than symbols - they can be redefined and 
be more than simple constant numbers

== data directives ==
data directives are usd in data segments to define room for memory 

Theres two ways memory can be reserved:
- The first way only defines room for data
- the second way defines room and an initial value. 
  
1) the first method uses one of the RESX directives, where the X is replaced 
    with a letter that determines the size of the object that will be stored. 
    Table 1.3 show sthe possible values:

Table 1.3:
| ------------- | -------- | ---------- |
| unit          | letter   | bit count  |
|---------------|----------|------------|
| byte          | B        | 8          |
| word          | W        | 16         |
| double word   | D        | 32         |
| quad word     | Q        | 64         |
| ten bytes     | T        | 80         |
|---------------|----------|------------|
note: 
bytes are 8 bits (a bit is a 0 or 1)
a word is 2 byes, a double word is 4 bytes, etc etc

2) the second method (that defines an initial value as well) uses the 
   DX directives. the X leters are same in the RESX directives for the 
   size of the object. Its common to mark memory locations with _labels_. 
   labels allow one to refer to memory locations in code. 
   
EXAMPLE;

L1      db      0       ;byte labeled L1 with initial value 0
L2      dw      1000    ;byte labelled L2 with initial value 1000
L3      db      110101b ;byte initialised to binary (53 in decimal)
L4      resb    1       ; 1 uninitialised byte
L5      db      "A"     ; byte initialised to ASCII for A

double quotes and single quotes are treated hte same. 
Consecutive data definitions are stored sequentially in memory. (
the word L2 is stored immediately after L1 in memory.) 

memory sequences may also be defined:

L9      db      0, 1, 2, 3      ;defines 4 bytes
L10     db      "w","o","r","d",0 ; defines a C string = "word"
L11     db      'word', 0       ; same s L10

the dd directive can be used to define both integer and single preccision 
floating point constants. The DQ directive can only be used to define double 
precision floating point constnats.

For large sequences, nasm's TIMES directive is pretty useful - this directive 
repeats its oeprand a sepcfied number of times 

L12     times   db 0            ; equilvalant to 100 (db 0)'s'
L13     resw    100             ; reserves room for 100 words.

== labels ==
remember that labels can be used to refer to data in code - there are two ways 
a label can be used, if a plan label is used, its the address its holding. if
[] is used, then its the data at the address. Think of this like pointers and 
the square bracket deferences it like how it does in C.

mov     al, [L1]        ; copy byte at L1 into AL
mov     eax, L1         ; copy address of byte at L1 
mov     [L1], ah        ; copy AH into byte at L1
mov     eax, [L6]       ; copy double word at L6 into EAX
add     [L6], eax       ; copy double word at L6 += EAX
mov     al, [L6]        ; copy first byte of double word at L6 into Al 

the last line shows and important proerty - the assembler doesn't keep track of 
the type of data a label refers to. Its up to us to make sure we use the label correctly
consder this:

mov     [L6], 1         ;store a 1 at L6 

this will yeild an operation size not specified error. This is becuase the assembler
doesn't know whether to store the 1 as a byte, word or double word. To fix this,
add a size specifier

mov     dword [L6], 1   ; store a 1 at L6

this tells the assembler to store a 1 at the double word that starts at L6. 

Other byte specifiers are BYTE, WORD, QWORD and TWORD
